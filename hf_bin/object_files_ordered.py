#!/usr/bin/python
# -*- coding: UTF-8 -*-

# Copyright (C) 2016 Michel Müller, Tokyo Institute of Technology

# This file is part of Hybrid Fortran.

# Hybrid Fortran is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# Hybrid Fortran is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public License
# along with Hybrid Fortran. If not, see <http://www.gnu.org/licenses/>.




#Original script by D. Dickinson
#Adapted by https://github.com/ZedThree
#.. adapted again by Michel Müller to fit Hybrid Fortran

import os
import re
import collections

class OrderedSet(collections.MutableSet):

    def __init__(self, iterable=None):
        self.end = end = []
        end += [None, end, end]         # sentinel node for doubly linked list
        self.map = {}                   # key --> [key, prev, next]
        if iterable is not None:
            self |= iterable

    def __len__(self):
        return len(self.map)

    def __contains__(self, key):
        return key in self.map

    def add(self, key):
        if key not in self.map:
            end = self.end
            curr = end[1]
            curr[2] = end[1] = self.map[key] = [key, curr, end]

    def discard(self, key):
        if key in self.map:
            key, prev, next = self.map.pop(key)
            prev[2] = next
            next[1] = prev

    def __iter__(self):
        end = self.end
        curr = end[2]
        while curr is not end:
            yield curr[0]
            curr = curr[2]

    def __reversed__(self):
        end = self.end
        curr = end[1]
        while curr is not end:
            yield curr[0]
            curr = curr[1]

    def pop(self, last=True):
        if not self:
            raise KeyError('set is empty')
        key = self.end[1][0] if last else self.end[2][0]
        self.discard(key)
        return key

    def __repr__(self):
        if not self:
            return '%s()' % (self.__class__.__name__,)
        return '%s(%r)' % (self.__class__.__name__, list(self))

    def __eq__(self, other):
        if isinstance(other, OrderedSet):
            return len(self) == len(other) and list(self) == list(other)
        return set(self) == set(other)

def makeTree(deps_as_dict_of_lists):
    def getDeps(cur_file):
        return deps_as_dict_of_lists.get(cur_file, [])

    deps = {}
    cur_files = [(fname,deps) for fname in deps_as_dict_of_lists.keys()]
    all_deps = {}
    while cur_files:
        cur_file, cur_deps = cur_files.pop()
        if cur_file in all_deps:
            cur_deps[cur_file] = all_deps[cur_file]
            continue
        new_deps = {}
        # getDeps returns the dependencies needed by cur_file.
        for dep in getDeps(cur_file):
            cur_files.append((dep,new_deps))
        cur_deps[cur_file] = new_deps
        all_deps[cur_file] = new_deps
    return deps

def _walkTree(tree,cur_files,walked_files):
    def iterate(node):
        if isinstance(node, dict):
            return node.items()
        else:
            return

    #inspired by http://code.activestate.com/lists/python-list/407341/
    for cur_file, cur_deps in tree.items():
        if cur_file in walked_files:
            continue
        elif cur_file in cur_files:
            # Deal with circular deps here. You might just do:
            raise StopIteration
            # raise ValueError, "Circular tree structure: %s" %(cur_file)
        if cur_deps:
            for sub_file in _walkTree(cur_deps,cur_files+(cur_file,),walked_files):
                yield sub_file
        walked_files.append(cur_file)
        yield cur_file

def walkTree(tree):
    """Walk a tree as generated by makeTree."""
    for f in _walkTree(tree,(),[]):
        yield f

def change_extension(file, build='', ext=".o"):
    return os.path.join(build, file.split(".")[0]) +ext

#Definitions
def run(files=None,verbose=True,overwrite=None,output=None,macros={},build=''):

    l=create_file_objs(files,macros)
    mod2fil=file_objs_to_mod_dict(file_objs=l)
    depends=get_depends(fob=l,m2f=mod2fil)

    print depends
    for objfile in OrderedSet([change_extension(f) for f in walkTree(makeTree(depends))]):
        print objfile

    if verbose:
        for i in depends.keys():
            print "\033[032m"+i+"\033[039m depends on :\033[034m"
            for j in depends[i]: print "\t"+j
            print "\033[039m"

    if output is None:
        output = "makefile.dep"

    tmp=write_depend(outfile=output,dep=depends,overwrite=overwrite,build=build)

    return depends

def write_depend(outfile="makefile.dep",dep=[],overwrite=False,build=''):
    "Write the dependencies to outfile"
    #Test file doesn't exist
    if os.path.exists(outfile):
        if not(overwrite):
            print "\033[031mWarning file exists.\033[039m"
            opt=raw_input("Overwrite? Y... for yes.")
        else:
            opt="y"
        if opt.lower().startswith("y"):
            pass
        else:
            return

    #Open file
    f=open(outfile,'w')
    f.write('# This file is generated automatically. DO NOT EDIT!\n')
    for i in dep.keys():
        tmp,fil=os.path.split(i)
        stri="\n"+change_extension(fil, build) + " : "
        for j in dep[i]:
            tmp,fil=os.path.split(j)
            stri=stri+" \\\n\t"+change_extension(fil, build)
        stri=stri+"\n"
        f.write(stri)
    f.close()
    return

def get_source(ext=[".f90",".F90",".h90",".H90",".P90"]):
    "Return all files ending with any of ext"
    tmp=os.listdir(".")
    fil=[]
    for i in ext:
        fil.extend(filter(lambda x: x.endswith(i),tmp))
    return fil

def create_file_objs(files=None, macros={}):
    l=[]

    if files is None:
        files = get_source()

    for i in files:
        source_file = file_obj()

        source_file.file_name = i
        source_file.uses = get_uses(i,macros)
        source_file.contains = get_contains(i)

        l.append(source_file)

    return l

def get_uses(infile=None, macros={}):
    "Return which modules are used in infile after expanding macros"
    p=re.compile("^\s*use\s*(?P<moduse>\w*)\s*(,)?\s*(only)?\s*(:)?.*?$",re.IGNORECASE).match

    uses=[]

    with open(infile,'r') as f:
        t=f.readlines()

    for i in t:
        tmp=p(i)
        if tmp:
            uses.append(tmp.group('moduse').strip())

    # Remove duplicates
    uniq_mods = list(set(uses))

    for i, mod in enumerate(uniq_mods):
        for k, v in macros.items():
            if re.match(k, mod, re.IGNORECASE):
                uniq_mods[i] = mod.replace(k,v)

    return uniq_mods

def get_contains(infile=None):
    "Return all the modules that are in infile"
    p=re.compile("^\s*module\s*(?P<modname>\w*)",re.IGNORECASE).match

    contains=[]

    with open(infile,'r') as f:
        t=f.readlines()

    for i in t:
        tmp=p(i)
        if tmp:
            contains.append(tmp.group('modname').strip())

    # Remove duplicates before returning
    return list(set(contains))

def file_objs_to_mod_dict(file_objs=[]):
    "Turn a list of file_objs in a dictionary, containing which modules depend on which files"
    dic={}
    for i in file_objs:
        for j in i.contains:
            dic[j.lower()]=i.file_name
    return dic

def get_depends(fob=[],m2f=[]):
    deps={}
    for i in fob:
        tmp=[]
        for j in i.uses:
            try:
                tmp.append(m2f[j.lower()])
            except:
                print "\033[031mError\033[039m module \033[032m"+j+"\033[039m not defined in any files. Skipping..."

        deps[i.file_name]=tmp

    return deps

class file_obj:
    def __init__(self):
        self.file_name=None
        self.uses=None
        self.contains=None
        self.depends_on=None


#Script
if __name__ == "__main__":
    import argparse

    # Add command line arguments
    parser = argparse.ArgumentParser(description='Generate Fortran dependencies')
    parser.add_argument('-f','--files',nargs='+',help='Files to process')
    parser.add_argument('-D',nargs='+',action='append',metavar='NAME=DESCRIPTION',
                        help="""The macro NAME is replaced by DEFINITION in 'use' statements""")
    parser.add_argument('-b','--build',nargs=1,help='Build Directory (prepended to all files in output',
                        default='')
    parser.add_argument('-o','--output',nargs=1,help='Output file')
    parser.add_argument('-v','--verbose',action='store_true',help='explain what is done')

    # Parse the command line arguments
    args = parser.parse_args()

    # Assemble a dictionary out of the macro definitions
    macros = {}
    if args.D:
        for arg in args.D:
            for var in arg:
                temp = var.split('=')
            macros[temp[0]] = temp[1]

    output = args.output[0] if args.output else None
    build = args.build[0] if args.build else ''

    run(files=args.files, verbose=args.verbose, overwrite=True, macros=macros, output=output, build=build)
